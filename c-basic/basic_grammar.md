# 基础语法相关


## 数据类型
> 基本数据类型
它们是算术类型，包括整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

注意： 1个字节是8位(bit)
类型	存储大小	值范围
char	        1 字节	-128 到 127 或 0 到 255  
unsigned char	1 字节	0 到 255   
signed char	    1 字节	-128 到 127    
int	            2 或 4 字节	-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647    
unsigned int	2 或 4 字节	0 到 65535 或 0 到 4,294,967,295   
short	        2 字节	-32,768 到 32,767    
unsigned short	2 字节	0 到 65535      
long	        4 字节	-2,147,483,648 到 2,147,483,647   
unsigned long	4 字节	0 到 4,294,967,295   


浮点类型

类型	存储大小	值范围	精度
float	4 字节	1.2E-38 到 3.4E+38	6 位有效位
double	8 字节	2.3E-308 到 1.7E+308	15 位有效位
long double	16 字节	3.4E-4932 到 1.1E+4932	19 位有效位



## 常量

# define 与 const 区别
> define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

#define 预处理指令和 const 关键字在定义常量时有一些区别：

替换机制：#define 是进行简单的文本替换，而 const 是声明一个具有类型的常量。#define 定义的常量在编译时会被直接替换为其对应的值，而 const 定义的常量在程序运行时会分配内存，并且具有类型信息。

类型检查：#define 不进行类型检查，因为它只是进行简单的文本替换。而 const 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。

作用域：#define 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 const 定义的常量具有块级作用域，只在其定义所在的作用域内有效。

调试和符号表：使用 #define 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 const 定义的常量会在符号表中有相应的条目，有助于调试和可读性。


## 存储类

### auto  
默认
### register 
寄存器变量, 因为存在寄存器中，不在内存中，所以没有内存地址, 不能用&来取地址.
### static 
存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

### static 
修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置

### extern
如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。


# 判断/循环

C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。




静态库, 动态
大端，小端
fork



1、预处理,生成 .i 的文件[预处理器cpp]
2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]
3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as], 即目标代码,
4、链接目标代码, 生成可执行程序 [链接器ld]


gcc -c test.c  只激活预处理,编译,和汇编,也就是他只把程序做成obj文件


objdump -t   test.o  

test.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 test.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .rodata        0000000000000000 .rodata
0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame      0000000000000000 .eh_frame
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 g     F .text  0000000000000058 main
0000000000000000         *UND*  0000000000000000 printf








objdump -T   test.o  

test.o:     file format elf64-x86-64

objdump: test.o: not a dynamic object
DYNAMIC SYMBOL TABLE:
no symbols



## 进程内存管理

栈：
栈是用于管理函数调用和局部变量的内存区域。它采用后进先出 (LIFO) 数据结构，这意味着最近添加的项目将首先被删除。调用函数时，其局部变量和函数参数将分配在堆栈上。函数退出时，其分配的堆栈空间将被释放，从而使堆栈能够高效地管理作用域绑定数据，即它在函数调用和返回期间会自动增大和缩小。
堆栈内存有限，过度分配或深的函数调用链会导致堆栈溢出，从而导致程序崩溃

用来存放局部变量，函数的参数，返回值等，由编译器自动分配释放。如一个函数被调用后,产生的临时变量都会存到栈区的顶部,当函数完成后,会自动从顶部将刚使用的数据销毁。栈区的地址是从高地址向下增长的。


堆
与堆栈不同，堆是用于动态内存分配的动态内存区域。程序员必须使用 malloc()、calloc()、realloc() 和 free() 等函数明确管理堆上分配的内存。堆内存不会自动释放，并且可以持续存在于单个函数的范围之外。
堆对于处理具有动态大小的数据结构至关重要，例如在运行时确定大小的数组或链接列表和树等复杂数据结构。不正确的堆内存管理可能会导致内存泄漏或碎片化，由于分配了小块但未使用的内存，内存利用效率低下。



BSS（以符号开始的块 Block Started by Symbol）段：
BSS 段包含未初始化的全局变量和静态变量。这些变量在程序开始执行之前被初始化为零或空值。由于这些变量未在代码中显式初始化，因此 BSS 段会减小可执行文件的大小，因为只存储变量和大小。
声明全局变量或静态变量时，如果未进行显式初始化，例如int uninitializedVar ;，则将其放置在 BSS 段中。但是，如果变量已初始化，则它们将存储在数据段中。 


数据段 data：
数据段保存已初始化的全局变量和静态变量。这些变量具有在程序编译期间设置的预定义值。与 BSS 段不同，数据段占用可执行文件中的空间来存储变量及其初始值。
全局变量（可在整个程序中访问）和静态变量（仅限于其定义范围）存储在数据段中。例如，int globalVar = 42; 将导致将 globalVar 存储在数据段中。 

用来存放有初始值的全局变量、全部静态变量（static 关键字定义的变量）。注意全部静态变量包括全局静态变量和局部静态变量，并且不论这些变量是否有初始值。即不管有没有初始值，也不管是全局变量还是定义在函数内的局部变量，只要是用 static 关键字定义的变量，都放在 .data 数据段内。



文本片段 text：
文本段，也称为代码段，包含程序指令的编译后的机器代码。此段是只读的，保存着 CPU 在程序运行时获取和执行的可执行指令。
由于文本段是只读的，因此尝试修改其内容将导致分段错误或程序崩溃。此段负责程序的实际功能和执行流程。

text 用来存放代码和常量（const 关键字定义的变量）


gcc -g 调试信息